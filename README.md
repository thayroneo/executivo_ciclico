# Executivo C√≠clico

## Objetivo

  Fazer a analise de um conjunto de tarefas (arquivo .json) para determinar se o sistema √© escalon√°vel ou n√£o. Caso seja escalon√°vel, mostrar a organiza√ß√£o das tarefas no per√≠odo maior;

  A organiza√ß√£o dessas tarefas deve seguir uma heur√≠stica conhecida, foi utilizada a heur√≠stica Highest Rate First - HRF;

* Maior Taxa de Periodicidade Primeiro (Highest Rate First - HRF): Nesta abordagem, as tarefas s√£o priorizadas com base na frequ√™ncia de sua execu√ß√£o; tarefas que devem ser executadas mais frequentemente t√™m prioridade. Isso √© baseado na l√≥gica de que tarefas com per√≠odos mais curtos s√£o geralmente mais cr√≠ticas e, portanto, devem ser atendidas com maior prioridade para evitar a viola√ß√£o de seus prazos.

## üîß Funcionalidades
### C√°lculo dos tempos de ciclo

* Tempo de ciclo prim√°rio: calculado como o m√≠nimo m√∫ltiplo comum (MMC) de todos os per√≠odos das tarefas, representando o ciclo maior que sincroniza todas as tarefas em sua periodicidade.

* Tempo de ciclo secund√°rio: determinado como o maior divisor comum (MDC) dos per√≠odos das tarefas, representando o menor ciclo poss√≠vel que ainda respeita as periodicidades das tarefas.

### C√°lculo do escalonamento usando heur√≠sticas

  A heur√≠stica considera os tempos de execu√ß√£o das tarefas, seus per√≠odos e prioridades para organizar a sequ√™ncia de execu√ß√£o dentro do ciclo.

## Formato de entrada

```
json
{
  "tarefas": [
    {
      "id": "Tarefa1",
      "periodo": 100,
      "tempo_execucao": 10,
      "prioridade": 1
    },
    {
      "id": "Tarefa2",
      "periodo": 200,
      "tempo_execucao": 20,
      "prioridade": 2
    },
    {
      "id": "Tarefa3",
      "periodo": 50,
      "tempo_execucao": 5,
      "prioridade": 3
    }
  ]
}
```

### Detalhes do formato de entrada

- id: identificador √∫nico para cada tarefa.
- periodo: o per√≠odo de cada tarefa ou intervalo de tempo entre as execu√ß√µes.
- tempo_execucao: o tempo necess√°rio para completar a tarefa.
- prioridade: n√∫mero que indica a prioridade da tarefa, sendo 1 a mais alta.


## üß© Constru√ß√£o

### Classe JsonManager
  Cria√ß√£o de uma classe, que recebesse o caminho para o arquivo json e que, posteriormente, conseguisse ler os itens separadamente, al√©m de conseguir ter acesso a cada caracter√≠stica de cada item separadamente.

```
class JsonManager:

    def __init__(self):
        self.path = dirname(realpath(__file__)) + '/'

    
    def read_json(self, file):
        if isfile(self.path + file):
            with open(self.path + file) as f:
                data = load(f)
            return data
        else:
            return False
```

### Requisito principal

  Uma das necessidades para que o escalonamento seja poss√≠vel √© que a Taxa de Utiliza√ß√£o (U) seja menor que 1, logo, caso U > 1, o Executivo √© invi√°vel.

$$
U = \sum_{i=0}^{\infty} \frac{e_i}{P_i} \leq 1
$$

Para isso, temos:

```
def taxa_ultiliza():

    data = jmanager.read_json('data/tarefas.json')
    range_tarefas = range(0, len(data))

    taxa_utilizacao = 0

    for i in range_tarefas:
        taxa_utilizacao += (data[i]['tempo_execut'])/(data[i]['periodo'])
    
    return taxa_utilizacao
```

Esse tipo de escalonamento implica na exist√™ncia de dois ‚Äúciclos‚Äù, um menor, onde as tarefas s√£o alocadas com prioridade no menor per√≠odo, e, uma maior, que vai se repetir ao longo do tempo.

![Diagrama√ß√£o do Executivo](data/img/diagrama.png)

O c√°lculo do ciclo maior √© mais simples, j√° que √© apenas o M√≠nimo M√∫ltiplo Comum (MMC) entre os per√≠odos.

```
def calculo_MMC():
    data = jmanager.read_json('data/tarefas.json')
    range_tarefas = range(0, len(data))
    periodo = []

    for i in range_tarefas:
        periodo.append(int(data[i]['periodo']))

    # Calcular o MMC dos per√≠odos
    result = periodo[0]
    for num in periodo[1:]:
        result = lcm(result, num)

    return result
```

### Requisitos secund√°rios

O c√°lculo do ciclo menor tem alguns requisitos que devem ser cumpridos, por√©m uma boa estimativa √© o M√°ximo Divisor Comum (MDC) entre os per√≠odos das tarefas, por√©m isso n√£o √© suficiente para afirmar que ser√° escalon√°vel nesse tempo. Logo, √© necess√°rio testar alguns poss√≠veis valores para o ciclo menor.

* Requisito #1:
O tamanho do frame deve ser maior ou igual ao maior tempo de execu√ß√£o de uma tarefa:

$$
f \geq \max(e_i)
$$


* Requisito #2:
O tamanho dos frames candidatos deve caber igualmente dentro de um ciclo maior.

* Requisito #3:
Deve existir um frame entre o release-time ((t‚Äô)) e o deadline ((t‚Äô + D_l)) de todos os jobs:

$$
2f - \text{gcd}(p_i,f) \leq D_i, 
$$

Para descobrir os poss√≠veis valores do ciclo menor √© criado uma lista ‚Äúf‚Äù que recebe os valores de ‚Äúx‚Äù que satisfazem essas condi√ß√µes

```
   while(x != 0):

        if x > ciclo_maior:
            break

        for i in range_tarefas:
            if x > tempo_execut[i]:
                if (2*x - gcd(periodo[i],x) <= periodo[i] ):
                    if (ciclo_maior % x) == 0:
                        f.append(x)
            x += 1
```

## üë®‚Äçüíª Desenvolvimento do algoritmo

Os valores salvos em ‚Äúf‚Äù s√£o testados logo ap√≥s, para isso, √© criada uma vari√°vel auxiliar que vai receber um valor da fun√ß√£o ‚Äúheur√≠stica‚Äù, ela tenta alocar as tarefas, com base na maior periodicidade primeiro, dentro do ciclo maior com esse poss√≠vel valor ‚Äúx‚Äù como ciclo menor
Nessa fun√ß√£o, √© feito um teste para saber se as tarefas realmente se repetiram a quantidade de vezes necess√°ria, caso n√£o, h√° um retorno False para vari√°vel auxiliar, caso contr√°rio,  o valor do ciclo menor foi achado.

```
for i in range(len(f)):

        print(f'Testando:  {f[i]}', end='\n\n')
        aux = heuristica(ciclo_maior, f[i])[1]

        if aux != False:
            ciclo_menor_correto = f[i]
            break
        else:
            print(f'O valor {f[i]} √© INV√ÅLIDO', end = '\n\n')
            ciclo_menor_correto = False
```
```
def heuristica(ciclo_maior, ciclo_menor):

    data = jmanager.read_json('data/tarefas.json')
    range_tarefas = range(0, len(data))

    prioridade = []
    tempo_execut = []

    periodo_ordenado = []
    periodo_modificado = []

    repeticoes = []
    for i in range_tarefas:
        prioridade.append(data[i]['tarefa'])
        tempo_execut.append(data[i]['tempo_execut'])
        periodo_ordenado.append(data[i]['periodo'])
        periodo_modificado.append(data[i]['periodo'])
        repeticoes.append(ciclo_maior/data[i]['periodo'])

    periodo_ordenado = selection_sort(periodo_ordenado, tempo_execut, periodo_modificado, prioridade, repeticoes)[0]
    tempo_execut = selection_sort(periodo_ordenado, tempo_execut, periodo_modificado, prioridade, repeticoes)[1]
    periodo_modificado = selection_sort(periodo_ordenado, tempo_execut, periodo_modificado, prioridade, repeticoes)[2]
    prioridade = selection_sort(periodo_ordenado, tempo_execut, periodo_modificado, prioridade, repeticoes)[3]
    repeticoes = selection_sort(periodo_ordenado, tempo_execut, periodo_modificado, prioridade, repeticoes)[4]
```

Ao utilizar a fun√ß√£o ‚Äúselection_sort‚Äù, essas listas s√£o organizadas com base na prioridade estabelecida anteriormente em que o maior per√≠odo tem a m√°xima prioridade.

```
def selection_sort(lista, lista_2, lista_3, lista_4, lista_5):
    n = len(lista)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if lista[j] < lista[min_idx]:
                min_idx = j
        lista[i], lista[min_idx] = lista[min_idx], lista[i]
        lista_2[i], lista_2[min_idx] = lista_2[min_idx], lista_2[i]
        lista_3[i], lista_3[min_idx] = lista_3[min_idx], lista_3[i]
        lista_4[i], lista_4[min_idx] = lista_4[min_idx], lista_4[i]
        lista_5[i], lista_5[min_idx] = lista_5[min_idx], lista_5[i]
    
    return [lista, lista_2, lista_3, lista_4, lista_5]
```

No algoritmo, cada tarefa √© avaliada em cada ciclo menor, usando um per√≠odo modificado. Esse per√≠odo √© atualizado a cada itera√ß√£o do ciclo maior, permitindo que tarefas com per√≠odos mais longos sejam consideradas novamente nos ciclos menores.

```
ciclos = []
    qt_ciclos = ciclo_maior/ciclo_menor
    tempo = 0
    ciclo_atual = []
    for j in range(0, int(qt_ciclos)):
        for i in range_tarefas:
            if (tempo + tempo_execut[i]) <= ciclo_menor and len(ciclos) < qt_ciclos: 
                if periodo_modificado[i] >= periodo_ordenado[i]:
                    ciclo_atual.append(prioridade[i])
                    repeticoes[i] -= 1
                    tempo += tempo_execut[i]
                    periodo_modificado[i] = 0
            if periodo_modificado[i] < periodo_ordenado[i]:
                periodo_modificado[i] += ciclo_menor
```

 Al√©m disso, o n√∫mero de repeti√ß√µes de cada tarefa √© atualizado a cada ciclo maior e verificado no final para determinar o sucesso do escalonamento.

```
 ciclos.append(ciclo_atual)  
 
        ciclo_atual = []
        tempo = 0

    aux = 0
    for i in repeticoes:
        if i != 0:
            aux += 1
    if aux != 0:
        return [False, False]

    return [prioridade, ciclos]
```

Agora, basicamente tem o in√≠cio da chamada das fun√ß√µes, que √© onde o programa come√ßa sua compila√ß√£o. Primeiramente, √© mostrado a quantidade total de tarefas, depois √© mostrado a taxa de utiliza√ß√£o em porcentagem, e caso essa taxa seja maior que 1, o programa para, j√° que o sistema n√£o √© escalon√°vel.

```
os.system('cls')
jmanager = JsonManager()

data = jmanager.read_json('data/tarefas.json')
json_size = len(data)
range_tarefas = range(0, len(data))
print(f'A quantidade de tarefas √©: {json_size}')

taxa_utilizacao = taxa_ultiliza()
print(f'A taxa de utiliza√ß√£o √© {taxa_utilizacao*100}%',end = "\n\n")

if taxa_utilizacao > 1:
    print('Sistema imposs√≠vel de ser escalonado')
    exit()
```

S√£o inicializadas vari√°veis como ciclo menor, ciclo maior e uma lista "f" que ser√° preenchida posteriormente. Al√©m disso, o c√≥digo preenche listas com os valores de per√≠odo e tempo de execu√ß√£o vindos de um arquivo .json, caso a taxa de utiliza√ß√£o seja inferior a 1, a compila√ß√£o continua.
```
else:

    ciclo_maior = calculo_MMC()
    ciclo_menor = calculo_MDC()
 

    tempo_execut = []
    periodo = []

    f = []


    for i in range_tarefas:
        tempo_execut.append(data[i]['tempo_execut'])
        periodo.append(data[i]['periodo'])

    print('Testando poss√≠veis valores de ciclo menor:', end='\n')
```

Logo ap√≥s, esse trecho h√° o preenchimento da lista ‚Äúf‚Äù com os valores poss√≠veis para o ciclo menor:

```
x = 1

    while(x != 0):

        if x > ciclo_maior:
            break

        for i in range_tarefas:
            if x > tempo_execut[i]:
                if (2*x - gcd(periodo[i],x) <= periodo[i] ):
                    if (ciclo_maior % x) == 0:
                        f.append(x)
            x += 1
    
    print(f'{f} \n\n')
```

No pr√≥ximo trecho, h√° os testes dos poss√≠veis valores de ‚Äúf‚Äù, faz-se isso com a chamada da fun√ß√£o ‚Äúheur√≠stica‚Äù, caso haja retorno False, ent√£o o valor de ciclo menor n√£o satisfaz a heur√≠stica, caso seja diferente, ent√£o o valor √© aceito.

```
   for i in range(len(f)):

        print(f'Testando:  {f[i]}', end='\n\n')
        aux = heuristica(ciclo_maior, f[i])[1]

        if aux != False:
            ciclo_menor_correto = f[i]
            break
        else:
            print(f'O valor {f[i]} √© INV√ÅLIDO', end = '\n\n')
            ciclo_menor_correto = False
```

Caso nenhum valor seja aceito para o ciclo menor, ent√£o o conjunto de tarefas n√£o √© escalon√°vel, ent√£o √© dado um exit. Por√©m, se esse valor existir, o programa continua, √© mostrado os valores dos ciclos, as tarefas com seus devidos per√≠odos e tempos de execu√ß√£o, a ordem de prioridade e como cada ciclo menor foi organizado no ciclo maior.

```
if ciclo_menor_correto == False:
        print('N√£o ESCALON√ÅVEL')

        exit()

    ciclo_maior = calculo_MMC()
    print(f'O Ciclo Maior do Executivo C√≠clico √©: {ciclo_maior} unidades de tempo', end='\n')

    
    print(f'O Ciclo Menor do Executivo C√≠clico √©: {ciclo_menor_correto} unidades de tempo', end="\n\n")
```
```
for i in range_tarefas:
        print(f'{data[i]['tarefa']} tem o per√≠odo: {data[i]['periodo']}')
    
    print('',end = '\n\n')

    for i in range_tarefas:
        print(f'{data[i]['tarefa']} tem tempo de execu√ß√£o: {data[i]['tempo_execut']}')
    
    print('',end = '\n\n')
    
    
  
    print('Heur√≠stica escolhida: HRF',end ='\n\n')

    prio = heuristica(ciclo_maior, ciclo_menor_correto)[0]
    ciclo = heuristica(ciclo_maior, ciclo_menor_correto)[1]

    print('As prioridades s√£o: ',f'\n {prio} \n')

    print('Os ciclos menores s√£o: ', end='\n\n')

    try:
        for i in range(0,len(ciclo)):
            print(f'CICLO {i+1}: ', end = '\n')
            print(f'\n {ciclo[i]} \n' )
    except:
        print(ciclo)
```

## üìä Resultados
### Para o conjunto 1

 ```
A quantidade de tarefas √©: 5
A taxa de utiliza√ß√£o √© 95.0%

Testando poss√≠veis valores de ciclo menor:
[4, 5, 8, 10, 20, 40, 80]

Testando:  4
O valor 4 √© INV√ÅLIDO

Testando:  5
O valor 5 √© INV√ÅLIDO

Testando:  8
O valor 8 √© INV√ÅLIDO

Testando:  10
O valor 10 √© INV√ÅLIDO

Testando:  20
O Ciclo Maior do Executivo C√≠clico √©: 80 unidades de tempo
O Ciclo Menor do Executivo C√≠clico √©: 20 unidades de tempo

Tarefa 1 tem o per√≠odo: 20
Tarefa 2 tem o per√≠odo: 20
Tarefa 3 tem o per√≠odo: 40
Tarefa 4 tem o per√≠odo: 40
Tarefa 5 tem o per√≠odo: 80

Tarefa 1 tem tempo de execu√ß√£o: 8
Tarefa 2 tem tempo de execu√ß√£o: 7
Tarefa 3 tem tempo de execu√ß√£o: 4
Tarefa 4 tem tempo de execu√ß√£o: 3
Tarefa 5 tem tempo de execu√ß√£o: 2

Heur√≠stica escolhida: HRF

As prioridades s√£o:
 ['Tarefa 1', 'Tarefa 2', 'Tarefa 3', 'Tarefa 4', 'Tarefa 5']

Os ciclos menores s√£o:

CICLO 1:
 ['Tarefa 1', 'Tarefa 2', 'Tarefa 3']

CICLO 2:
 ['Tarefa 1', 'Tarefa 2', 'Tarefa 4', 'Tarefa 5']

CICLO 3:
 ['Tarefa 1', 'Tarefa 2', 'Tarefa 3']

CICLO 4:
 ['Tarefa 1', 'Tarefa 2', 'Tarefa 4']
```

### Para o conjunto 2

```
Resultado 2:

A quantidade de tarefas √©: 5
A taxa de utiliza√ß√£o √© 92.0%

Testando poss√≠veis valores de ciclo menor:
[5, 10, 20, 25, 50, 100]

Testando:  5
O valor 5 √© INV√ÅLIDO

Testando:  10
O valor 10 √© INV√ÅLIDO

Testando:  20
O valor 20 √© INV√ÅLIDO

Testando:  25
O Ciclo Maior do Executivo C√≠clico √©: 100 unidades de tempo
O Ciclo Menor do Executivo C√≠clico √©: 25 unidades de tempo

Tarefa 1 tem o per√≠odo: 25
Tarefa 2 tem o per√≠odo: 25
Tarefa 3 tem o per√≠odo: 50
Tarefa 4 tem o per√≠odo: 50
Tarefa 5 tem o per√≠odo: 100

Tarefa 1 tem tempo de execu√ß√£o: 10
Tarefa 2 tem tempo de execu√ß√£o: 8
Tarefa 3 tem tempo de execu√ß√£o: 5
Tarefa 4 tem tempo de execu√ß√£o: 4
Tarefa 5 tem tempo de execu√ß√£o: 2

Heur√≠stica escolhida: HRF

As prioridades s√£o:  
 ['Tarefa 1', 'Tarefa 2', 'Tarefa 3', 'Tarefa 4', 'Tarefa 5']

Os ciclos menores s√£o:

CICLO 2:
 ['Tarefa 1', 'Tarefa 2', 'Tarefa 4']

CICLO 3:
 ['Tarefa 1', 'Tarefa 2', 'Tarefa 3']

CICLO 4:
 ['Tarefa 1', 'Tarefa 2', 'Tarefa 4']

```

### Conjunto 3

```
Resultado 3: 

A quantidade de tarefas √©: 3   
A taxa de utiliza√ß√£o √© 55.00000000000001%

Testando poss√≠veis valores de ciclo menor:
[4, 5, 10]

Testando:  4
O Ciclo Maior do Executivo C√≠clico √©: 20 unidades de tempo    
O Ciclo Menor do Executivo C√≠clico √©: 4 unidades de tempo     

Tarefa 1 tem o per√≠odo: 10     
Tarefa 2 tem o per√≠odo: 10     
Tarefa 3 tem o per√≠odo: 20     

Tarefa 1 tem tempo de execu√ß√£o: 2
Tarefa 2 tem tempo de execu√ß√£o: 3
Tarefa 3 tem tempo de execu√ß√£o: 1

Heur√≠stica escolhida: HRF      

As prioridades s√£o:
 ['Tarefa 1', 'Tarefa 2', 'Tarefa 3']

Os ciclos menores s√£o:

CICLO 1:
 ['Tarefa 1', 'Tarefa 3']      

CICLO 2:
 ['Tarefa 2']

CICLO 3:
 []

CICLO 4:
 ['Tarefa 1']

CICLO 5:
 ['Tarefa 2']

```


### Conjunto 4 - Caso de ERRO

```
Resultado 4:

A quantidade de tarefas √©: 4
A taxa de utiliza√ß√£o √© 100.0%

Testando poss√≠veis valores de ciclo menor:
[8, 12, 16, 24, 48]

Testando:  8
O valor 8 √© INV√ÅLIDO

Testando:  12
O valor 12 √© INV√ÅLIDO

Testando:  16
O valor 16 √© INV√ÅLIDO

Testando:  24
O valor 24 √© INV√ÅLIDO

Testando:  48
O valor 48 √© INV√ÅLIDO

```

## üì∫V√≠deo de Demonstra√ß√£o

[![V√≠deo de Demonstra√ß√£o](https://img.youtube.com/vi/mE8hrT-NejE/hqdefault.jpg)](https://youtu.be/mE8hrT-NejE)

## üëç Conclus√£o

Desenvolver um executivo c√≠clico que analise um conjunto de tarefas em um arquivo .json para determinar a escalabilidade do sistema √© um passo fundamental na gest√£o eficiente de recursos computacionais. Ao aplicar uma heur√≠stica como a Highest Rate First (HRF), podemos priorizar tarefas com taxas de utiliza√ß√£o mais altas, o que pode levar a um melhor aproveitamento dos recursos e a um escalonamento mais eficaz.

## ‚úíÔ∏è Colaboradores
* **Bruno Nascimento de Oliveira** - [BRUNONASCIOLI](https://github.com/BRUNONASCIOLI)
* **Jos√© Tayrone Santos de Oliveira** - [thayroneo](https://github.com/thayroneo)
* **Yuri Siqueira Dantas** - [YuriDants](https://github.com/YuriDants)

Voc√™ tamb√©m pode ver a lista de todos os [colaboradores](https://github.com/BRUNONASCIOLI/Projeto_STR/colaboradores) que participaram deste projeto.
